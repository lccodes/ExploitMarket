package edu.brown.game;

import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import edu.brown.agent.Agent;
import edu.brown.agent.FirmAgent;
import edu.brown.agent.HackerAgent;
import edu.brown.agent.InvestorAgent;
import edu.brown.agent.VerifierAgent;
import edu.brown.assets.Exploit;
import edu.brown.assets.PredictionMarkets;
import edu.brown.signals.Offer;
import edu.brown.support.Label;

public class World {
	private List<Label<HackerAgent>> hackers;
	private List<Label<InvestorAgent>> investors;
	private List<Label<VerifierAgent>> verifiers;
	private List<Label<FirmAgent>> firms;
	private List<ExploitStatus> exploits;
	private Map<Long, Account> bank;
	private Set<Offer> offers;
	private final PredictionMarkets pm;
	
	private Set<Long> IDS;
	private final SecureRandom sr;
	private volatile Boolean running, over;
	private final ExecutorService executor;
	
	private final boolean MIDGAMEADD = false;
	
	public World() {
		sr = new SecureRandom();
		hackers = Collections.synchronizedList(new ArrayList<Label<HackerAgent>>());
		investors = Collections.synchronizedList(new ArrayList<Label<InvestorAgent>>());
		firms = Collections.synchronizedList(new ArrayList<Label<FirmAgent>>());
		verifiers = Collections.synchronizedList(new ArrayList<Label<VerifierAgent>>());
		exploits = Collections.synchronizedList(new ArrayList<ExploitStatus>());
		bank = Collections.synchronizedMap(new HashMap<Long, Account>());
		IDS = Collections.synchronizedSet(new HashSet<Long>());
		offers = Collections.synchronizedSet(new HashSet<Offer>());
		pm = new PredictionMarkets();
		this.running = false;
		this.over = false;
		executor = Executors.newFixedThreadPool(15);
	}
	
	/*
	 * Generates an exploit and assigns it to a firmagent
	 * Passes it to a hacker
	 */
	private synchronized void mineExploit() {
		Exploit e = Exploit.generate(firms.get((int) (firms.size() * sr.nextDouble())).ID);
		exploits.add(new ExploitStatus(e));
		HackerAgent hacker = hackers.get((int) (hackers.size() * sr.nextDouble())).agent;
		executor.submit(() -> hacker.newExploit(e));
	}
	
	/*
	 * Begins the game loop
	 */
	public void run() {
		if (over) {
			return;
		}
		
		synchronized (running) {
			//Init agents
			synchronized(hackers) {
				for (Label<HackerAgent> hacker : hackers) {
					new Thread(hacker.agent)
						.start();
				}
			}
			
			synchronized(investors) {
				for (Label<InvestorAgent> investor : investors) {
					new Thread(investor.agent)
						.start();
				}
			}
			
			synchronized(verifiers) {
				for (Label<VerifierAgent> verifier : verifiers) {
					new Thread(verifier.agent)
						.start();
				}
			}
			
			synchronized(firms) {
				for (Label<FirmAgent> firm : firms) {
					new Thread(firm.agent)
						.start();
				}
			}
			
			if (running) {
				return;
			} else {
				this.running = true;
			}
			
			long time = System.currentTimeMillis();
			while (!over) {
				if (System.currentTimeMillis() - time >= 300000) {
					time = System.currentTimeMillis();
					mineExploit();
				}
			}
		}
		
	}
	
	/*
	 * Adds an agent to the game
	 */
	public void addAgent(HackerAgent agent) {
		if (!MIDGAMEADD) {
			return;
		}
		Long ID = assignID(agent);
		hackers.add(new Label<HackerAgent>(ID, agent));
	}
	
	public void addAgent(InvestorAgent agent) {
		if (!MIDGAMEADD && running || over) {
			return;
		}
		Long ID = assignID(agent);
		investors.add(new Label<InvestorAgent>(ID, agent));
	}
	
	public void addAgent(FirmAgent agent) {
		if (!MIDGAMEADD && running || over) {
			return;
		}
		Long ID = assignID(agent);
		firms.add(new Label<FirmAgent>(ID, agent));
	}
	
	public void addAgent(VerifierAgent agent) {
		if (!MIDGAMEADD && running || over) {
			return;
		}
		Long ID = assignID(agent);
		verifiers.add(new Label<VerifierAgent>(ID, agent));
	}
	
	private Long assignID(Agent agent) {
		Long ID = sr.nextLong();
		while (IDS.contains(ID)) {
			ID = sr.nextLong();
		}
		
		agent.setID(ID);
		bank.put(ID, new Account());
		
		return ID;
	}
	
	/*
	 * Gets game status
	 */
	public boolean isRunning() {
		return running && !over;
	}
	
	/*
	 * Ends the game
	 */
	public synchronized void endGame() {
		if (over) {
			return;
		}
		over = true;
	}
	
	public boolean contains(long ID) {
		return IDS.contains(ID);
	}
	
	public boolean giveOffer(long from, long to, Offer o) {
		for (Label<? extends Agent> agent : getAgents()) {
			if (agent.ID == to) {
				if (offers.contains(o)) {
					return true;
				}
				executor.submit(() -> agent.agent.offer(from, o));
				offers.add(o);
				return true;
			}
		}
		
		return false;
	}
	
	public boolean acceptOffer(long from, Offer o) {
		if (!offers.contains(o) || o.FROM != from) {
			return false;
		}
		
		return executeOffer(o);
	}
	
	public Long getID(Agent a) {
		for (Label<? extends Agent> agent : getAgents()) {
			if (agent.agent.equals(a)) {
				return agent.ID;
			}
		}
		
		return null;
	}
	
	public List<Label<? extends Agent>> getAgents() {
		List<Label<? extends Agent>> agents = new ArrayList<Label<? extends Agent>>();
		
		agents.addAll(hackers);
		agents.addAll(verifiers);
		agents.addAll(investors);
		agents.addAll(firms);
		
		return agents;
	}
	
	private boolean executeOffer(Offer offer) {
		Agent to = null, from = null;
		for (Label<? extends Agent> agent : getAgents()) {
			if (agent.ID == offer.TO) {
				to = agent.agent;
			} else if (agent.ID == offer.FROM) {
				from = agent.agent;
			}
		}
		if (to == null || from == null) {
			return false;
		}
		
		final Agent TO = to;
		final Agent FROM = from;
		Account accountTo = bank.get(TO);
		Account accountFrom = bank.get(FROM);
		if (offer.PRICE >= 0) {
			Optional<Exploit> exploit = accountFrom.getExploit(offer.NAME, offer.FIRMAGENT);
			if (!exploit.isPresent()) {
				return false;
			}
			accountFrom.removeExploit(exploit.get());
			accountTo.addExploit(exploit.get());
			
			accountFrom.pay(offer.PRICE);
			accountTo.withdraw(offer.PRICE);
		} else {
			Optional<Exploit> exploit = accountTo.getExploit(offer.NAME, offer.FIRMAGENT);
			if (!exploit.isPresent()) {
				return false;
			}
			accountFrom.addExploit(exploit.get());
			accountTo.removeExploit(exploit.get());
			
			accountFrom.withdraw(offer.PRICE);
			accountTo.pay(offer.PRICE);
		}
		
		executor.submit(() -> TO.update(accountTo.immutable()));
		executor.submit(() -> FROM.update(accountFrom.immutable()));
		
		return false;
	}
	
	public boolean verify(Exploit e) {
		for (ExploitStatus es : exploits) {
			if (es.exploit.equals(e)) {
				return true;
			}
		}
		
		return false;
	}

	public synchronized Future<Exploit> requestVerify(Offer offer) {
		if (this.contains(offer.FROM)) {
			for (Label<HackerAgent> hacker : hackers) {
				if (hacker.ID == offer.FROM) {
					return executor.submit(() -> hacker.agent.exploitFromOffer(offer));
				}
			}
			
			for (Label<InvestorAgent> hacker : investors) {
				if (hacker.ID == offer.FROM) {
					return executor.submit(() -> hacker.agent.exploitFromOffer(offer));
				}
			}
			
			for (Label<FirmAgent> hacker : firms) {
				if (hacker.ID == offer.FROM) {
					return executor.submit(() -> hacker.agent.exploitFromOffer(offer));
				}
			}
		}
		
		return null;
	}

	public void expose(Exploit e) {
		for (ExploitStatus es : exploits) {
			if (es.exploit.equals(e)) {
				es.eliminate();
				pm.close(e);
				break;
			}
		}
	}
	
	public void disclose(Exploit e) {
		for (ExploitStatus es : exploits) {
			if (es.exploit.equals(e)) {
				es.eliminate();
				for (Label<FirmAgent> firm : firms) {
					if (firm.ID == e.FIRMAGENT) {
						firm.agent.disclose(e);
						break;
					}
				}
				break;
			}
		}
	}
	
}
